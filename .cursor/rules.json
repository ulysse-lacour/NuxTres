{
  "rules": [
    {
      "name": "Project Directory Structure",
      "description": "Informs the assistant about the project's directory structure.",
      "match": "*",
      "message": "This project is built with Nuxt and Tres.js. Key directories include: `components/` (Vue components), `composables/` (reusable functions), `stores/` (Pinia stores), `layouts/` (Nuxt layouts), `pages/` (Nuxt pages/routes), `public/` (static assets), `assets/` (style assets)"
    },
    {
      "name": "Tres.js Component Organization",
      "description": "Guides the assistant on organizing Tres.js related components.",
      "match": "*",
      "message": "Organize Three.js components within the `components/` directory.  Consider a structure like `tres/components/` for reusable components (e.g., custom geometries, materials) and `tres/scenes/` for entire scenes or logical groupings of objects. Use descriptive folder names."
    },
    {
      "name": "State Management with Pinia",
      "description": "Encourages the use of Pinia for state management.",
      "match": "*.vue",
      "message": "Utilize Pinia for managing application state (e.g., game state, player data, UI settings).  Create Pinia stores in the `stores/` directory using the `useStoreName()` naming convention.  Use these stores within your components to access and modify the application state. No need to import the store, it will be auto-imported."
    },
    {
      "name": "Using Nuxt Composables",
      "description": "Encourages the use of Nuxt composables for reusable logic.",
      "match": "*.vue",
      "message": "Create composables in the `composables/` directory to encapsulate reusable logic (e.g., game input handling, calculations, API calls). Use the `useComposableName()` naming convention. Import and use these composables within your components to keep them clean and maintainable."
    },
    {
      "name": "Asset Handling (Images, Models, Textures)",
      "description": "Guides the assistant on how to handle assets efficiently.",
      "match": "*",
      "message": "Place static assets (images, models, textures, etc.) in the `public/` directory.  Reference these assets using absolute paths (e.g., `/images/my-texture.png`). For assets loaded dynamically within Three.js, consider using the `useLoader` composable from `@tresjs/cientos` for optimized loading and caching."
    },
    {
      "name": "GLSL Shaders",
      "description": "Reminds the assistant how to handle GLSL shaders.",
      "match": "*.glsl",
      "message": "Store GLSL shader files (vertex and fragment shaders) in a dedicated directory (e.g., `assets/shaders/`). Use the `vite-plugin-glsl` plugin (already installed) to import these shaders directly into your JavaScript/Vue code.  This allows you to write shaders in separate files with proper syntax highlighting."
    },
    {
      "name": "Animations with GSAP",
      "description": "Suggests using GSAP for animations.",
      "match": "*.vue",
      "message": "Leverage GSAP (GreenSock Animation Platform) for creating complex animations. GSAP is already installed and offers a powerful and flexible way to animate Three.js objects, UI elements, or any other numeric property.  Import GSAP with `const { $gsap } = useNuxtApp();`. Then you can use gsap functions like `$gsap.to()`, `$gsap.from()`, `$gsap.timeline()`."
    },
    {
      "name": "Asynchronous Operations",
      "description": "Reminds the assistant to handle asynchronous operations correctly.",
      "match": "*.vue",
      "message": "When performing asynchronous operations (e.g., loading models, fetching data), use `async/await` syntax for cleaner code. Handle potential errors using `try/catch` blocks.  Consider using Nuxt's `useAsyncData` composable for data fetching within pages and components."
    },
    {
      "name": "Component Reusability",
      "description": "Encourages the creation of reusable components.",
      "match": "*",
      "message": "Design components to be reusable and configurable. Use props to pass data into components and emit events to communicate changes back to the parent component.  This promotes modularity and maintainability."
    },
    {
      "name": "Typescript Usage",
      "description": "Reminds that the Project is using Typescript",
      "match": "*",
      "message": "The Project is using Typescript, ensure to declare the correct types and interfaces to have a good dev experience"
    },
    {
      "name": "Client-Side Components",
      "description": "Guidelines for client-side components",
      "match": "*.client.vue",
      "message": "Components with '.client.vue' extension are only rendered on the client side. Use this naming convention for all Three.js/TresJS components and scenes that rely on browser-specific APIs."
    },
    {
      "name": "TresJS Canvas Component",
      "description": "Proper usage of TresCanvas component",
      "match": "*.vue",
      "message": "Always wrap Three.js content in a <TresCanvas> component. Use the window-size attribute for responsive canvases. Configure the renderer with v-bind properties like clearColor, shadows, etc."
    },
    {
      "name": "Cientos Library Usage",
      "description": "Guidelines for using Cientos components",
      "match": "*.vue",
      "message": "Use @tresjs/cientos library for common Three.js abstractions like OrbitControls, useGLTF, PerspectiveCamera, etc. Import them with: import { ComponentName } from '@tresjs/cientos';"
    },
    {
      "name": "Debugging with Tweakpane",
      "description": "Guidelines for using Tweakpane for debugging",
      "match": "*.vue",
      "message": "Use Tweakpane for creating debug UI panels. Import with: import { Pane } from 'tweakpane'; Create panes in onMounted hooks and use them to expose and manipulate component properties during development."
    },
    {
      "name": "Tailwind CSS Styling",
      "description": "Guidelines for using Tailwind CSS",
      "match": "*.vue",
      "message": "The project uses Tailwind CSS for styling. Use utility classes directly in templates. For complex components, use the 'tv' function from tailwind-variants to create component variants with conditional styling."
    },
    {
      "name": "Component File Structure",
      "description": "Guidelines for structuring component files",
      "match": "*.vue",
      "message": "Follow the standard Vue SFC structure: <template> at the top, followed by <script setup lang=\"ts\"> with clear sections for imports, refs/reactive state, lifecycle hooks, and methods. Add comments to separate these sections for better readability."
    }
  ]
}
